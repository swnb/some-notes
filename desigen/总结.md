# 总结

> 总结下 elab-web 的项目

## 起始

项目起始于生物实验的简单需求，一个拖放系统，它的诞生基于3样基本的东西，我下面介绍下

## 什么是 createMoveAble ？

createMoveAble 是一个函数，通过调用该函数可以将dom节点变成拖动对象，要理解这个模块，就要先知道另外3个模块：

1 Resolve

2 MousePosition

3 Store

我大致解释下这3个模块：

Resolve：简单来说 Resolve 解析鼠标或者dom的位置信息，输出最基本的单元位置信息 -> [x,y] （左边是 x 坐标值 单位是 Number ，右边是 y 坐标值 单位也是 Number，理论上这是一个元组，对于js，我只能用数组表示），它的核心任务就是根据输入正确的输出位置信息，该模块包含很多的api

MousePosition：MousePosition 的任务是实时的监听页面的焦点（鼠标位置或者触摸位置）位置信息。当焦点变化的时候，MousePosition 通知外部焦点发生了变化。当然，为了优化性能，该模块可以由外部启动和制动，当MousePosition 得到了焦点的位置，它如何向外部发布这个信息呢？这就要靠 Store 了

Store：Store 是我要好好说一下的模块了，Store 诞生于我在编程时遇到的一些难题，最初的版本很简陋，之后经过不断演化而诞生的（几个月），它本身很简单，但是要理解这种简单需要你对程序有一定认识，它的初衷是要解决2个问题

1 通讯

2 跨模块

什么是通讯？这里的通讯指的是对象的通讯，如果按照前端的理解，那就是组件和组件之间的交互，

通讯是什么？通讯的核心是交换数据，可以没有交换，但是必须要引起数据的变化，拿面向对象举例吧，通讯无非是你调用我的方法（函数），我调用你的方法，我们就完成了一次通讯，但是通讯必然引系统状态的变化，这里的状态也就是程序的变量，

介绍完通讯，我解释下 Store 是如何处理这个问题的，Store 在内部创建了一个map，存储监听数据变化的回调函数的数组，当数据变化的时候，调用对应的回调函数。这里，你只需要知道Store可以监听数据变动即可。但是有一个问题你需要知道 当你更新某个数据时 Store 发现的新的值和旧的值是相同的，这个时候，Store 不会触发回调函数，为什么？因为之前我说过，通讯必须要伴随着状态的改变，说到这里你就理解了

Store 是整个系统的心脏，脱离了 Store ，整个系统都要崩掉，从侧面说明 心脏只能有一个（你不希望你的系统说崩就崩吧 :）

MousePosition 从设计上来说是为了让CMA(createmoveable)变得灵活，也就是俗称解耦合

Resolve 是为了兼容而设计的，它能为CMA提供强大的可维护性和极强的可扩展性!

如果有不对的地方，欢迎指正
 