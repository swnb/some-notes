# 浅谈并发模型

> 以 Node.js Python Golang Dart 等语言为例子,谈谈我理解的并发;

传统并发往往以系统线程为单位,使用线程池并发处理任务;但是对于 web 应用来说,大部分任务都是 IO 任务,这个时候如果线程池太小,那么大部分任务都处于 block ,没法充分利用 CPU ,效率不高;如果线程池过大, CPU 大部分时间都消耗在处理线程的上下文切换,非常低效;

---

## Node.js

上面的线程池模型很难处理高并发,Node.js 有两个基本概念:

- 异步 IO
- 事件驱动

Node.js 将所有 IO 任务都做了异步处理,底层使用 epoll 注册事件,等待事件触发, Node.js 维护了一段事件队列,每当事件触发的时候,将回调函数放入队列,等待当前的同步任务完成,便开始调用事件队列的任务继续运行,周而复始;这个模型性能高的原因有两点:

- 没有线程上下文切换(但是存在中断切换,也就是软中断)
- 不存在 IO 阻塞

但是由于 js 动态类型(存在运行时解释开销),再加 Node.js 不能充分利用多核(可以多进程,但这要根据业务需求来确定),因此效率一般;值得一提的是 Node.js 的异步 IO 的模型影响了同时代的很对语言;

---

## Python

Python 崇尚简单易用,为了避免并发并行带来的一系列安全问题和繁琐的解决方案,所以引入可全局锁,同一时刻只能做一件事;所以多线程对于 CPU 密集型应用无效,只能缓解 IO 压力,所以社区也提出了单线程的异步 IO 模型,但是由于语言本身效率低下,Python 的并发效率不高;

---

## lua

lua 最为知名的就是协程了,这一方面我了解不多,但是从使用上来看,跟 Node.js 没什么区别,不太了解底层的调度是怎样的; lua 有 2 点优势:

- lua 非常小巧,简单易学,非常灵活,并且是单线程,没什么开发难度;
- lua 作为动态类型语言性能优异,在 luajit 下更是明显;

---

## Erlang/Elixir

Erlang 是 Actor 并发模型的典例;回到最初线程池的实现,实际上这种并发模型的问题就在于线程的上下文太大了(主要是栈空间),一个 web request context 根本不需要这么大的系统资源,增加了内核的调度负担;这也就是轻量级线程的出发点,在用户态调度,使用更小的并发单元;

### Actor 模型

每个 actor (Elixir 叫进程)都是一个极其轻量级的并发单元(相对小的资源空间),所以 Erlang 可以支持百万级并发;Actor 把`不通过共享内存来通讯,用通讯来共享内存`这种哲学发挥的淋漓尽致;当一个 actor 跟其他 actor 进行通行的时候都需要找到后者的 ID ,然后发送消息到两者之间的邮箱(队列)里面,之后就可以去做自己的事情,不需要管后者是否收到消息,后者接收到消息后就去处理,邮箱空了就阻塞,整个过程完全异步,面向对象, actor 销毁后,自动清理占用资源;

Erlang 不仅仅得益于其并发模型,还有其 OTP 框架,这方面的知识体系太庞大,我也不懂;
ELixir 跟 Erlang 大致一样;

---

## Golang

> 不通过共享内存来通讯,用通讯来共享内存

Golang 是多核轻量级并发的代表, 在内核态实现了线程池,在用户态实现了 goroutine 的调度器,可以轻松实现百万级的并发, golang 放弃了线程和进程,使用栈空间极小的 goroutine 作为并发单元,这点跟 Erlang 很像,与 Erlang 不同的是, Golang 不关心它与哪一个 goroutine 在通信,他只跟 chan (通道)进行数据对接,而 Erlang 只对指定的 actor 进行通信, Golang 的 chan 就仿佛是一个中间人,使得 Golang 不需要关心通信的端点,由于 Golang 是静态类型的编译型语言,再加上并发模型的优良设计,在 web benchmark 上排名很靠前的(fasthttp);

---

## Dart

Dart 继承了 Node.js 的业内最佳实践,有 Future async/await Stream,可以说是很现代化的语言;在的单线程异步 IO 的基础上,实现了 isolate 并发,也就是不共享内存,用异步通讯来交还数据,类似 Erlang ,但是 Dart vm 现在效率一般,有待优化,现在还是效率一般.

---

## Rust

Rust 现在的情况很不明朗,官方只给了系统的线程模型,但之后还会有异步 async/await 和 channel 的设计,但是我对 Rust 很期待.目测性能会很高.
