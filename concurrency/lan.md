# 浅谈并发模型

> 以 Rust Golang Node.js Python Dart(Elixir) 为例子,谈谈我理解的并发并行;

传统并发往往以系统线程为单位,创建线程池,每个线程同步处理任务,对于 web 应用来说,大部分都是 IO 任务,这个时候如果线程池太小,那么大部分任务都是在 block ,没法充分利用 CPU ,效率不高.但是如果线程池过大, CPU 大部分时间都消耗在处理线程的上下文切换,非常低效.

---

上面的线程池模型很难处理高并发,再看看 Node.js ,两个基本基本概念:

- 异步 IO
- 事件驱动

Node.js 将所有 IO 任务都做了异步处理(Node.js 可以写同步代码),底层使用 epoll 注册事件,等待触发回调, Node.js 维护了一段事件队列,每当事件触发的时候,将回调函数放入队列,等待当前的同步任务完成,开始调用事件队列的任务继续运行,这个过程为什么一般比线程池模型效率高,

- 没有线程上下文切换(但是存在中断切换,也就是软中断)
- 不存在 IO 阻塞

但是 Node.js 本身动态类型,再加 Node.js 不能充分利用多核(可以多进程),因此效率一般.值得一提的是 Node.js 的异步 IO 的模型影响了同时代的很对语言.

---

Python 因为全局锁的原因,同一时刻只能运行一件事, 所以除非多进程,否则对于 CPU 密集型应用无效,只能多线程缓解 IO 压力,或者学习 Node.js 异步 IO,但是由于语言本身效率低下,Python 的并发效率不高.

---

Erlang Actor 模型,回到最初线程池的实现看看,实际上这种并发的问题就在于,线程的上下文太大了(主要是栈空间),一个 web request context 根本不需要这么大的系统资源,增加了内核的调度负担.这也就是轻量级线程的出发点,在用户态实现调度,更小的并发单元.

Actor 模型
每一 actor (Elixir 叫进程) 跟其他 actor 进行通行的时候都需要找到这个 actor 的 ID,然后发送消息到邮箱(队列)里面,之后去做自己的事情, 另外一个 actor 接收到消息后就去处理,邮箱空了就阻塞,整个过程完全异步,面向对象, actor 销毁后,自动清理资源.

Erlang 不仅仅得益于其并发模型,还有其 OTP 框架,这方面的知识太庞大.
ELixir 跟 Erlang 大致一样

---

Golang, Golang 是多核轻量级并发的代表, 在内核态实现了线程池,在用户态实现了 goroutine 的调度器,可以轻松实现百万级的并发,golang 放弃了线程和进程,使用栈空间极小的 goroutine 作为并发单元,这点跟 Erlang 很像,与 Erlang 不同的是,Golang 不关心它与哪一个 goroutine 在通信,他只跟 chan (通道)进行数据对接,而 Erlang 只对指定的 actor 进行通信,Golang chan 就仿佛是一个中间者,使得 Golang 不需要关心通信的断掉,由于 Golang 是编译型语言,再加上并发模型的优良设计,在 benchmark 上也是排名很靠前的,

---

Dart 继承了 Node.js 的最佳实践,有 Future async/await Stream,可以说是很现代化了,在的单线程异步 IO 的基础上,实现了 isolate 并发,也就是不共享内存,用异步通讯来交流,类似 Erlang,但是 Dart vm 现在效率很一般,优化空间巨大,期待中,现在还是效率低下.

---

Rust 现在的情况很不明朗,官方只给了系统的线程模型,但之后还会有异步 async/await 和 channel 的设计,但是我对 Rust 很期待.目测性能会很高.
